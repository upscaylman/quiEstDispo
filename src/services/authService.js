// Service d'authentification Firebase
import {
  FacebookAuthProvider,
  signOut as firebaseSignOut,
  getRedirectResult,
  GoogleAuthProvider,
  onAuthStateChanged,
  RecaptchaVerifier,
  signInWithPhoneNumber,
  signInWithPopup,
} from 'firebase/auth';
import {
  collection,
  deleteDoc,
  doc,
  getDoc,
  getDocs,
  query,
  serverTimestamp,
  setDoc,
  updateDoc,
  where,
} from 'firebase/firestore';
import { auth, db } from '../firebase';

// Utilitaire pour v√©rifier la connectivit√© (am√©lior√©)
const isOnline = () => {
  // navigator.onLine peut √™tre peu fiable, on assume connect√© par d√©faut
  if (typeof navigator === 'undefined') return true;

  // Si navigator.onLine dit offline, on fait confiance
  if (!navigator.onLine) return false;

  // Sinon on assume connect√© (Firebase g√®rera les erreurs r√©seau)
  return true;
};

// Utilitaire pour retry avec backoff optimis√©
const retryWithBackoff = async (fn, maxRetries = 2, baseDelay = 500) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
        const delay = baseDelay * Math.pow(1.5, i); // Moins agressif
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        throw error;
      }
    }
  }
};

// Service d'authentification ultra-simplifi√© avec App Check
export class AuthService {
  // Connexion avec Google selon la documentation officielle
  static async signInWithGoogle() {
    try {
      console.log('üî• Firebase: Starting Google sign-in...');

      const provider = new GoogleAuthProvider();
      provider.addScope('email');
      provider.addScope('profile');
      provider.setCustomParameters({
        prompt: 'select_account',
        hl: 'fr',
      });

      const result = await signInWithPopup(auth, provider);
      const credential = GoogleAuthProvider.credentialFromResult(result);
      const token = credential?.accessToken;

      console.log('‚úÖ Firebase: Google sign-in successful');

      if (process.env.NODE_ENV === 'development' && token) {
        console.log('üîë Google Access Token available for API calls');
      }

      if (result.user) {
        try {
          await this.createUserProfile(result.user);
        } catch (profileError) {
          console.warn(
            '‚ö†Ô∏è Profile creation failed, continuing anyway:',
            profileError
          );
        }
      }

      return {
        user: result.user,
        credential,
        token,
      };
    } catch (error) {
      console.error('‚ùå Google sign-in failed:', error);

      let errorMessage = 'Connexion Google √©chou√©e';
      switch (error.code) {
        case 'auth/popup-closed-by-user':
          errorMessage = "Connexion annul√©e par l'utilisateur";
          break;
        case 'auth/popup-blocked':
          errorMessage =
            'Popup bloqu√©e par le navigateur. Autorisez les popups pour ce site';
          break;
        case 'auth/cancelled-popup-request':
          errorMessage =
            'Demande de connexion annul√©e. Une autre connexion est en cours';
          break;
        case 'auth/account-exists-with-different-credential':
          errorMessage =
            'Un compte existe d√©j√† avec cette adresse email mais un autre fournisseur';
          break;
        case 'auth/operation-not-allowed':
          errorMessage =
            "Connexion Google non activ√©e. Contactez l'administrateur";
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Probl√®me de connexion. V√©rifiez votre internet';
          break;
        default:
          errorMessage = error.message || 'Connexion Google √©chou√©e';
      }
      throw new Error(errorMessage);
    }
  }

  // Connexion Google avec redirection (alternative pour appareils mobiles)
  static async signInWithGoogleRedirect() {
    try {
      console.log('üîÑ Starting Google sign-in with redirect...');

      const provider = new GoogleAuthProvider();
      provider.addScope('email');
      provider.addScope('profile');
      provider.setCustomParameters({
        prompt: 'select_account',
        hl: 'fr',
      });

      // D√©marrer la redirection
      // await signInWithRedirect(auth, provider); // TODO: Fix import
      throw new Error('Redirection Google non disponible pour le moment');
      // Note: La page va √™tre recharg√©e, le r√©sultat sera trait√© par getGoogleRedirectResult()
    } catch (error) {
      console.error('‚ùå Google redirect sign-in failed:', error);
      throw new Error(`Redirection Google √©chou√©e: ${error.message}`);
    }
  }

  // Connexion avec Facebook selon la documentation officielle
  static async signInWithFacebook() {
    try {
      console.log('üî• Firebase: Starting Facebook sign-in...');

      const provider = new FacebookAuthProvider();
      provider.addScope('email');
      provider.addScope('public_profile');
      provider.setCustomParameters({
        locale: 'fr_FR',
      });

      const result = await signInWithPopup(auth, provider);
      const credential = FacebookAuthProvider.credentialFromResult(result);
      const token = credential?.accessToken;

      console.log('‚úÖ Firebase: Facebook sign-in successful');

      if (process.env.NODE_ENV === 'development' && token) {
        console.log('üîë Facebook Access Token available for API calls');
      }

      if (result.user) {
        try {
          await this.createUserProfile(result.user);
        } catch (profileError) {
          console.warn(
            '‚ö†Ô∏è Profile creation failed, continuing anyway:',
            profileError
          );
        }
      }

      return {
        user: result.user,
        credential,
        token,
      };
    } catch (error) {
      console.error('‚ùå Facebook sign-in failed:', error);

      let errorMessage = 'Connexion Facebook √©chou√©e';
      switch (error.code) {
        case 'auth/popup-closed-by-user':
          errorMessage = "Connexion annul√©e par l'utilisateur";
          break;
        case 'auth/popup-blocked':
          errorMessage =
            'Popup bloqu√©e par le navigateur. Autorisez les popups pour ce site';
          break;
        case 'auth/cancelled-popup-request':
          errorMessage =
            'Demande de connexion annul√©e. Une autre connexion est en cours';
          break;
        case 'auth/account-exists-with-different-credential':
          errorMessage =
            'Un compte existe d√©j√† avec cette adresse email mais un autre fournisseur';
          break;
        case 'auth/operation-not-allowed':
          errorMessage =
            "Connexion Facebook non activ√©e. Contactez l'administrateur";
          break;
        case 'auth/user-disabled':
          errorMessage = 'Ce compte utilisateur a √©t√© d√©sactiv√©';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Probl√®me de connexion. V√©rifiez votre internet';
          break;
        default:
          errorMessage = error.message || 'Connexion Facebook √©chou√©e';
      }
      throw new Error(errorMessage);
    }
  }

  // Connexion Facebook avec redirection (alternative pour appareils mobiles)
  static async signInWithFacebookRedirect() {
    try {
      console.log('üîÑ Starting Facebook sign-in with redirect...');

      const provider = new FacebookAuthProvider();
      provider.addScope('email');
      provider.addScope('public_profile');
      provider.setCustomParameters({
        locale: 'fr_FR',
      });

      // D√©marrer la redirection
      // await signInWithRedirect(auth, provider); // TODO: Fix import
      throw new Error('Redirection Facebook non disponible pour le moment');
      // Note: La page va √™tre recharg√©e, le r√©sultat sera trait√© par getFacebookRedirectResult()
    } catch (error) {
      console.error('‚ùå Facebook redirect sign-in failed:', error);
      throw new Error(`Redirection Facebook √©chou√©e: ${error.message}`);
    }
  }

  // Valider et formater le num√©ro de t√©l√©phone au format E.164
  static validateAndFormatPhoneNumber(phoneNumber) {
    if (!phoneNumber || typeof phoneNumber !== 'string') {
      throw new Error('Num√©ro de t√©l√©phone requis');
    }

    // Supprimer tous les espaces, tirets et autres caract√®res non num√©riques sauf +
    let cleaned = phoneNumber.replace(/[^\d+]/g, '');

    // Si le num√©ro commence par 0 (format fran√ßais), remplacer par +33
    if (cleaned.startsWith('0')) {
      cleaned = '+33' + cleaned.substring(1);
    }
    // Si le num√©ro ne commence pas par +, ajouter +33 (par d√©faut France)
    else if (!cleaned.startsWith('+')) {
      cleaned = '+33' + cleaned;
    }

    // V√©rifier que le num√©ro a une longueur raisonnable (au moins 10 chiffres apr√®s +33)
    if (cleaned.length < 12) {
      // +33 + 9 chiffres minimum
      throw new Error('Num√©ro de t√©l√©phone trop court');
    }

    if (cleaned.length > 15) {
      // Limite E.164
      throw new Error('Num√©ro de t√©l√©phone trop long');
    }

    // Validation sp√©cifique pour les num√©ros mobiles fran√ßais (+336/+337 UNIQUEMENT)
    if (cleaned.startsWith('+33')) {
      const frenchNumber = cleaned.substring(3); // Enlever +33
      if (frenchNumber.length !== 9) {
        throw new Error('Le num√©ro fran√ßais doit avoir 9 chiffres apr√®s +33');
      }
      // CONTRAINTE M√âTIER: Seuls les mobiles fran√ßais 06 et 07 sont accept√©s
      if (!frenchNumber.match(/^[67][0-9]{8}$/)) {
        throw new Error(
          'Seuls les num√©ros mobiles fran√ßais (+336, +337) sont accept√©s'
        );
      }
    }

    console.log(`üì± Num√©ro format√©: ${phoneNumber} ‚Üí ${cleaned}`);
    return cleaned;
  }

  // Connexion avec t√©l√©phone
  static async signInWithPhone(phoneNumber, recaptchaVerifier, options = {}) {
    try {
      console.log('üì± Starting phone authentication...');

      // ‚ö†Ô∏è AM√âLIORATION: Cr√©er les callbacks Android-style
      const callbacks = this.createPhoneAuthCallbacks({
        onCodeSent: options.onCodeSent,
        onVerificationError: options.onVerificationError,
        onReCaptchaResolved: options.onReCaptchaResolved,
        onAppCheckError: options.onAppCheckError,
      });

      // Formatter le num√©ro de t√©l√©phone selon les standards E.164
      const formattedNumber = phoneNumber.startsWith('+')
        ? phoneNumber
        : `+33${phoneNumber.startsWith('0') ? phoneNumber.slice(1) : phoneNumber}`;

      console.log('üìû Formatted phone number:', formattedNumber);

      // ‚ö†Ô∏è AM√âLIORATION: V√©rifier si c'est un num√©ro de test (comme Android)
      const authSettings = /** @type {any} */ (auth.settings);
      const isTestNumber =
        authSettings?.testPhoneNumbers &&
        authSettings.testPhoneNumbers[formattedNumber];

      if (isTestNumber) {
        console.log(
          'üß™ Num√©ro de test d√©tect√© (mode Android):',
          formattedNumber
        );
        console.log(
          'üí° Code attendu:',
          authSettings.testPhoneNumbers[formattedNumber]
        );
      }

      // ‚ö†Ô∏è CORRECTION: V√©rifier la connectivit√© avant l'envoi
      if (!navigator.onLine) {
        const networkError = new Error('auth/network-request-failed');
        callbacks.onVerificationFailed(networkError);
        throw networkError;
      }

      // ‚ö†Ô∏è AM√âLIORATION: Timeout inspir√© d'Android (30 secondes par d√©faut)
      const timeout = options.timeout || 30000;
      console.log(
        `‚è±Ô∏è Configuration timeout: ${timeout / 1000}s (comme Android)`
      );

      // ‚ö†Ô∏è CORRECTION: Attendre un d√©lai pour √©viter les conflits reCAPTCHA
      await new Promise(resolve => setTimeout(resolve, 100));

      try {
        // Envoyer le SMS selon la documentation Firebase
        const confirmationResult = await Promise.race([
          signInWithPhoneNumber(auth, formattedNumber, recaptchaVerifier),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('auth/timeout')), timeout)
          ),
        ]);

        console.log('‚úÖ SMS sent successfully');

        // D√©clencher le callback onCodeSent (comme Android)
        callbacks.onCodeSent(confirmationResult.verificationId, null);

        return confirmationResult;
      } catch (sendError) {
        // ‚ö†Ô∏è AM√âLIORATION: D√©tecter sp√©cifiquement les erreurs App Check (cause erreur 500)
        if (
          sendError.message &&
          (sendError.message.includes('500') ||
            sendError.message.includes('app-check') ||
            sendError.message.includes('sendVerificationCode'))
        ) {
          callbacks.onAppCheckError(sendError);
        }

        throw sendError;
      }
    } catch (error) {
      // ‚ö†Ô∏è AM√âLIORATION: Utiliser la gestion d'erreurs centralis√©e inspir√©e de iOS
      const errorInfo = this.handleAuthError(error, 'phone authentication');

      // ‚ö†Ô∏è AM√âLIORATION: Log d√©taill√© pour debug (comme Android)
      console.group('üîç Diagnostic erreur SMS (style Android)');
      console.log('Num√©ro format√©:', phoneNumber);
      console.log('Settings auth:', auth.settings);
      console.log(
        'Test numbers configur√©s:',
        /** @type {any} */ (auth.settings)?.testPhoneNumbers
      );
      console.log('Code erreur:', error.code);
      console.log('Message erreur:', error.message);
      console.groupEnd();

      // Lancer l'erreur avec le message utilisateur am√©liorer
      throw new Error(errorInfo.userMessage);
    }
  }

  // Cr√©er un v√©rificateur reCAPTCHA
  static createRecaptchaVerifier(elementId, options = {}) {
    try {
      console.log('üîß Creating reCAPTCHA verifier...');

      // ‚ö†Ô∏è CORRECTION: V√©rifier que l'√©l√©ment existe avant de cr√©er le verifier
      const element = document.getElementById(elementId);
      if (!element) {
        throw new Error(
          `√âl√©ment DOM '${elementId}' introuvable. V√©rifiez que <div id="${elementId}"></div> existe dans le HTML.`
        );
      }

      // ‚ö†Ô∏è CORRECTION: Nettoyer les anciens verifiers sur cet √©l√©ment
      if (element.innerHTML) {
        element.innerHTML = '';
        console.log('üßπ Ancien reCAPTCHA nettoy√©');
      }

      // ‚ö†Ô∏è OFFICIEL: Configuration selon la documentation Firebase Web officielle
      // R√©f√©rence: https://firebase.google.com/docs/auth/web/phone-auth
      console.log(
        'üìö Configuration reCAPTCHA selon la documentation Firebase Web officielle'
      );

      // La doc officielle recommande 'invisible' pour une meilleure UX
      const recaptchaSize = options.size || 'invisible';
      console.log(`üîê Type reCAPTCHA: ${recaptchaSize} (selon doc officielle)`);

      // Configuration simplifi√©e selon la documentation officielle
      const recaptchaConfig = {
        size: recaptchaSize,
        callback: response => {
          // reCAPTCHA r√©solu - selon doc officielle
          console.log('‚úÖ reCAPTCHA resolved (conforme doc officielle)');
          if (options.onSuccess) options.onSuccess(response);
        },
        'expired-callback': () => {
          // reCAPTCHA expir√© - selon doc officielle
          console.log('‚ö†Ô∏è reCAPTCHA expired (comportement doc officielle)');
          if (options.onExpired) options.onExpired();
        },
        'error-callback': error => {
          // Erreur reCAPTCHA - selon doc officielle
          console.error('‚ùå reCAPTCHA error (gestion doc officielle):', error);
          if (options.onError) options.onError(error);
        },
      };

      // ‚ö†Ô∏è OFFICIEL: Cr√©er le RecaptchaVerifier exactement comme dans la doc
      let recaptchaVerifier;
      try {
        // Syntaxe exacte de la documentation Firebase Web officielle
        recaptchaVerifier = new RecaptchaVerifier(
          auth,
          elementId,
          recaptchaConfig
        );

        console.log(
          '‚úÖ RecaptchaVerifier cr√©√© selon la documentation officielle Firebase Web'
        );
      } catch (verifierError) {
        console.error('‚ùå RecaptchaVerifier creation failed:', verifierError);

        // ‚ö†Ô∏è OFFICIEL: Gestion d'erreur selon les bonnes pratiques doc officielle
        if (
          verifierError.message &&
          verifierError.message.includes('sitekey')
        ) {
          throw new Error(
            'üîë Configuration reCAPTCHA manquante (selon doc officielle)\n\n' +
              '‚úÖ Solutions selon la documentation Firebase Web :\n' +
              '1. Configurez une cl√© reCAPTCHA v3 dans Firebase Console\n' +
              '2. Ajoutez REACT_APP_RECAPTCHA_V3_SITE_KEY dans votre .env\n' +
              '3. Ou utilisez appVerificationDisabledForTesting = true pour les tests\n' +
              '4. Utilisez le bouton "üß™ Test SMS" avec les num√©ros fictifs\n\n' +
              'üìö R√©f√©rence: https://firebase.google.com/docs/auth/web/phone-auth\n' +
              'üí° Num√©ro test officiel: +16505554567 / Code: 123456'
          );
        }

        if (
          verifierError.message &&
          verifierError.message.includes('app-check')
        ) {
          throw new Error(
            'üö® Conflit App Check d√©tect√© (cause erreur 500)\n\n' +
              '‚úÖ Solution selon la documentation Firebase :\n' +
              '1. D√©sactivez App Check dans Firebase Console\n' +
              '2. Utilisez appVerificationDisabledForTesting = true\n' +
              '3. Testez avec les num√©ros fictifs officiels\n\n' +
              'üìö Doc officielle confirme cette approche pour les tests'
          );
        }

        throw new Error(`Erreur reCAPTCHA: ${verifierError.message}`);
      }

      return recaptchaVerifier;
    } catch (error) {
      console.error('‚ùå Error creating reCAPTCHA verifier:', error);
      console.error('‚ùå Details (debug selon doc officielle):', {
        elementId,
        options,
        nodeEnv: process.env.NODE_ENV,
        authSettings: auth.settings,
        elementExists: !!document.getElementById(elementId),
        windowLocation: window.location.href,
        appVerificationDisabled:
          auth.settings?.appVerificationDisabledForTesting,
        officialTestMode: /** @type {any} */ (auth.settings)?.testPhoneNumbers
          ? Object.keys(
              /** @type {any} */ (auth.settings).testPhoneNumbers
            ).includes('+16505554567')
          : false,
      });
      throw new Error(
        error.message ||
          `Impossible de cr√©er le v√©rificateur reCAPTCHA: ${error.message}`
      );
    }
  }

  // Confirmer le code de v√©rification
  static async confirmPhoneCode(confirmationResult, verificationCode) {
    try {
      console.log('üî¢ Confirming verification code...');

      const result = await confirmationResult.confirm(verificationCode);
      console.log('‚úÖ Phone verification successful');

      // V√©rifier si ce num√©ro existe d√©j√† dans un compte existant
      if (result.user && result.user.phoneNumber) {
        const linkedUser = await this.handlePhoneAccountLinking(result.user);
        return linkedUser; // Retourner l'utilisateur li√© ou cr√©√©
      }

      return result.user; // Fallback au cas o√π
    } catch (error) {
      // Ne pas afficher ACCOUNT_LINKING_SUCCESS comme une erreur
      if (error.message !== 'ACCOUNT_LINKING_SUCCESS') {
        console.error('‚ùå Code verification failed:', error);
      }

      let errorMessage = 'Code de v√©rification invalide';
      switch (error.code) {
        case 'auth/invalid-verification-code':
          errorMessage = 'Code de v√©rification invalide';
          break;
        case 'auth/code-expired':
          errorMessage = 'Code de v√©rification expir√©';
          break;
        default:
          errorMessage = error.message || 'Erreur de v√©rification du code';
      }
      throw new Error(errorMessage);
    }
  }

  // G√©rer la liaison des comptes lors de la connexion par t√©l√©phone
  static async handlePhoneAccountLinking(phoneUser) {
    try {
      console.log(
        'üîç V√©rification si le num√©ro existe dans un compte existant...'
      );
      const phoneNumber = phoneUser.phoneNumber;

      // Chercher un utilisateur existant avec ce num√©ro de t√©l√©phone
      const usersQuery = query(
        collection(db, 'users'),
        where('phone', '==', phoneNumber)
      );

      const existingUsers = await getDocs(usersQuery);

      if (!existingUsers.empty) {
        // Plusieurs comptes peuvent avoir le m√™me num√©ro, prioriser celui avec un email (compte principal)
        let existingUserDoc = existingUsers.docs[0];
        let existingUserData = existingUserDoc.data();
        let existingUserId = existingUserDoc.id;

        // Si plusieurs r√©sultats, prioriser le compte avec un email
        if (existingUsers.docs.length > 1) {
          console.log(
            `‚ö†Ô∏è ${existingUsers.docs.length} comptes trouv√©s avec ce num√©ro, s√©lection du compte principal...`
          );

          const accountWithEmail = existingUsers.docs.find(doc => {
            const data = doc.data();
            return data.email && data.email.trim() !== '';
          });

          if (accountWithEmail) {
            existingUserDoc = accountWithEmail;
            existingUserData = existingUserDoc.data();
            existingUserId = existingUserDoc.id;
            console.log(
              `‚úÖ Compte principal s√©lectionn√©: ${existingUserData.name} (${existingUserData.email})`
            );
          }
        }

        console.log(
          `‚úÖ Compte existant trouv√©: ${existingUserData.name} (${existingUserId})`
        );

        // Comparer les UIDs
        if (existingUserId !== phoneUser.uid) {
          console.log('üîÑ Comptes diff√©rents d√©tect√©s, liaison n√©cessaire...');

          // D√©connecter le compte temporaire pour forcer la reconnexion avec le compte principal
          await firebaseSignOut(auth);

          // Informer l'utilisateur avec un message explicatif
          alert(
            `‚úÖ Parfait ! Votre num√©ro ${phoneNumber} a √©t√© ajout√© √† votre compte "${existingUserData.name}".\n\n` +
              `Reconnectez-vous avec votre email OU votre num√©ro de t√©l√©phone pour acc√©der au m√™me compte.`
          );

          // Retourner un signal sp√©cial pour indiquer qu'il faut se reconnecter
          throw new Error('ACCOUNT_LINKING_SUCCESS');
        } else {
          console.log('‚úÖ M√™me compte, mise √† jour des infos...');
          // C'est le m√™me compte, juste mettre √† jour
          await this.createUserProfile(phoneUser);
          return phoneUser; // Retourner l'utilisateur connect√©
        }
      } else {
        console.log('‚ÑπÔ∏è Nouveau num√©ro, cr√©ation du profil...');
        await this.createUserProfile(phoneUser);
        console.log('‚úÖ Nouvel utilisateur cr√©√© et connect√© !');
        return phoneUser; // Retourner l'utilisateur connect√©
      }
    } catch (error) {
      if (error.message === 'ACCOUNT_LINKING_SUCCESS') {
        throw error; // Re-lancer le signal sp√©cial
      }
      console.error('‚ùå Erreur liaison comptes:', error);
      // En cas d'erreur, cr√©er quand m√™me le profil
      await this.createUserProfile(phoneUser);
      return phoneUser; // Retourner l'utilisateur m√™me en cas d'erreur
    }
  }

  // Tester l'authentification SMS avec des num√©ros fictifs
  static async testPhoneAuth(
    testPhoneNumber = '+16505554567', // ‚ö†Ô∏è OFFICIEL: Num√©ro de la doc Firebase Web officielle
    testCode = '123456'
  ) {
    try {
      console.log('üß™ Testing phone auth with fictional numbers...');
      console.log(
        'üìö Configuration selon la documentation Firebase Web officielle'
      );
      console.log(
        'üîó R√©f√©rence: https://firebase.google.com/docs/auth/web/phone-auth'
      );

      // ‚ö†Ô∏è OFFICIEL: Configuration exacte de la documentation Firebase Web
      // Turn off phone auth app verification.
      auth.settings.appVerificationDisabledForTesting = true;

      console.log(
        'üîß appVerificationDisabledForTesting = true (selon doc officielle)'
      );

      // ‚ö†Ô∏è OFFICIEL: Utiliser le num√©ro et code exact de la documentation
      console.log('üì± Num√©ro de test officiel:', testPhoneNumber);
      console.log('üî¢ Code de test officiel:', testCode);

      // ‚ö†Ô∏è CORRECTION: Configurer les num√©ros de test directement
      const authSettings = /** @type {any} */ (auth.settings);
      if (!authSettings.testPhoneNumbers) {
        authSettings.testPhoneNumbers = {
          '+33612345678': '123456',
          '+1234567890': '123456',
          '+16505554567': '123456', // Num√©ro OFFICIEL de la doc
        };
        console.log('‚úÖ Num√©ros de test configur√©s selon la doc officielle');
      }

      // ‚ö†Ô∏è CORRECTION: Cr√©er un √©l√©ment temporaire pour le reCAPTCHA si n√©cessaire
      let tempElement = document.getElementById('recaptcha-container');
      let shouldCleanup = false;

      if (!tempElement) {
        tempElement = document.createElement('div');
        tempElement.id = 'temp-recaptcha-test';
        tempElement.style.display = 'none';
        document.body.appendChild(tempElement);
        shouldCleanup = true;
        console.log('üîß √âl√©ment reCAPTCHA temporaire cr√©√© pour test officiel');
      }

      // ‚ö†Ô∏è OFFICIEL: Cr√©er le reCAPTCHA exactement comme dans la doc
      console.log('üîê Cr√©ation du reCAPTCHA selon la doc officielle...');
      console.log(
        'üí° La doc indique: "This will render a fake reCAPTCHA as appVerificationDisabledForTesting is true"'
      );

      const recaptchaVerifier = this.createRecaptchaVerifier(tempElement.id, {
        size: 'invisible',
      });

      console.log('üì± Envoi SMS de test selon la documentation officielle...');

      // ‚ö†Ô∏è OFFICIEL: Appel signInWithPhoneNumber exactement comme dans la doc
      // signInWithPhoneNumber will call appVerifier.verify() which will resolve with a fake reCAPTCHA response.
      const confirmationResult = await this.signInWithPhone(
        testPhoneNumber,
        recaptchaVerifier
      );

      console.log('üî¢ Confirmation du code selon la doc officielle...');
      console.log(
        'üí° La doc indique: "confirmationResult can resolve with the fictional testVerificationCode"'
      );

      // ‚ö†Ô∏è OFFICIEL: Confirmer avec le code de test exactement comme dans la doc
      const result = await confirmationResult.confirm(testCode);

      console.log(
        '‚úÖ Test phone auth successful (conforme √† la documentation Firebase Web officielle)'
      );

      // ‚ö†Ô∏è CORRECTION: Nettoyer l'√©l√©ment temporaire
      if (shouldCleanup) {
        try {
          recaptchaVerifier.clear();
          document.body.removeChild(tempElement);
          console.log('üßπ √âl√©ment temporaire nettoy√©');
        } catch (cleanupError) {
          console.warn('‚ö†Ô∏è Erreur nettoyage:', cleanupError);
        }
      }

      return result.user;
    } catch (error) {
      // ‚ö†Ô∏è AM√âLIORATION: Utiliser la gestion d'erreurs centralis√©e inspir√©e de iOS
      const errorInfo = this.handleAuthError(
        error,
        'test phone authentication'
      );

      // ‚ö†Ô∏è SP√âCIFIQUE AU TEST: Messages selon la documentation officielle
      let testSpecificMessage = errorInfo.userMessage;

      if (error.message && error.message.includes('500')) {
        testSpecificMessage =
          'üö® Erreur 500 m√™me en mode test officiel\n\n' +
          'üìö Selon la documentation Firebase Web officielle :\n\n' +
          '1. üîß auth.settings.appVerificationDisabledForTesting doit √™tre true\n' +
          '2. üì± Seuls les num√©ros fictifs peuvent √™tre utilis√©s avec cette API\n' +
          '3. üö´ App Check doit √™tre D√âSACTIV√â dans Firebase Console\n' +
          '4. üåê Domaines autoris√©s doivent √™tre configur√©s\n\n' +
          '‚úÖ Actions IMM√âDIATES selon la doc officielle :\n' +
          '‚Ä¢ Firebase Console ‚Üí App Check ‚Üí D√âSACTIVER compl√®tement\n' +
          '‚Ä¢ Authentication ‚Üí Settings ‚Üí Authorized domains ‚Üí Ajouter vos domaines\n' +
          '‚Ä¢ Authentication ‚Üí Sign-in method ‚Üí Phone ‚Üí Configurer num√©ros test\n\n' +
          '‚è∞ Attendre 10-15 minutes pour propagation\n\n' +
          'üìö R√©f√©rence: https://firebase.google.com/docs/auth/web/phone-auth\n' +
          'üí° Num√©ro test officiel: +16505554567 / Code: 123456';
      }

      console.group('üß™ Diagnostic erreur test SMS (selon doc officielle)');
      console.log(
        'Num√©ro utilis√©:',
        testPhoneNumber,
        '(officiel:',
        testPhoneNumber === '+16505554567' ? 'OUI' : 'NON)'
      );
      console.log('Configuration auth.settings:', auth.settings);
      console.log(
        'appVerificationDisabledForTesting:',
        auth.settings?.appVerificationDisabledForTesting
      );
      console.log(
        'Num√©ros de test configur√©s:',
        /** @type {any} */ (auth.settings)?.testPhoneNumbers
      );
      console.log(
        'Num√©ro officiel configur√©:',
        /** @type {any} */ (auth.settings)?.testPhoneNumbers?.[
          '+16505554567'
        ] === '123456'
      );
      console.groupEnd();

      throw new Error(testSpecificMessage);
    }
  }

  // Cr√©er le profil utilisateur
  static async createUserProfile(user) {
    if (!isOnline()) {
      console.warn('‚ö†Ô∏è Offline mode, cannot create user profile');
      // Retourner les donn√©es de base en mode offline
      return {
        uid: user.uid,
        name: user.displayName || 'Utilisateur',
        email: user.email || null,
        phone: user.phoneNumber || null,
        avatar: user.photoURL || null,
        isOnline: false,
        isAvailable: false,
        currentActivity: null,
        availabilityId: null,
        location: null,
        friends: [],
      };
    }

    try {
      return await retryWithBackoff(async () => {
        const userRef = doc(db, 'users', user.uid);
        const userSnap = await getDoc(userRef);

        const now = new Date().toISOString();

        if (!userSnap.exists()) {
          const userData = {
            uid: user.uid,
            name: user.displayName || 'Utilisateur',
            email: user.email || null,
            phone: user.phoneNumber || null,
            avatar: user.photoURL || null,
            isOnline: true,
            isAvailable: false,
            currentActivity: null,
            availabilityId: null,
            location: null,
            friends: [],
            createdAt: now,
            updatedAt: serverTimestamp(),
          };

          await setDoc(userRef, userData);
          console.log('‚úÖ User profile created successfully');
          return userData;
        } else {
          await updateDoc(userRef, {
            isOnline: true,
            updatedAt: serverTimestamp(),
          });
          console.log('‚úÖ User profile updated (login)');

          // Retourner les donn√©es existantes avec la mise √† jour
          const existingData = userSnap.data();
          return {
            id: userSnap.id,
            ...existingData,
            isOnline: true,
          };
        }
      });
    } catch (error) {
      console.error('‚ùå Profile creation failed:', error);
      // En cas d'erreur, retourner les donn√©es de base Firebase Auth
      return {
        uid: user.uid,
        name: user.displayName || 'Utilisateur',
        email: user.email || null,
        phone: user.phoneNumber || null,
        avatar: user.photoURL || null,
        isOnline: true,
        isAvailable: false,
        currentActivity: null,
        availabilityId: null,
        location: null,
        friends: [],
      };
    }
  }

  // Obtenir le profil utilisateur
  static async getUserProfile(userId) {
    if (!isOnline()) {
      console.warn('‚ö†Ô∏è Offline mode, cannot get user profile');
      return null;
    }

    try {
      return await retryWithBackoff(async () => {
        const userRef = doc(db, 'users', userId);
        const userSnap = await getDoc(userRef);

        if (userSnap.exists()) {
          return { id: userSnap.id, ...userSnap.data() };
        }
        return null;
      });
    } catch (error) {
      console.error('‚ùå Get user profile failed:', error);
      throw new Error(`Impossible de r√©cup√©rer le profil: ${error.message}`);
    }
  }

  // D√©connexion
  static async signOut() {
    try {
      const user = auth.currentUser;
      if (user && isOnline()) {
        const userRef = doc(db, 'users', user.uid);
        await updateDoc(userRef, {
          isOnline: false,
          isAvailable: false,
          currentActivity: null,
          availabilityId: null,
          updatedAt: serverTimestamp(),
        });
      }

      await firebaseSignOut(auth);
      console.log('‚úÖ User signed out successfully');
    } catch (error) {
      console.error('‚ùå Sign out failed:', error);
      throw new Error(`D√©connexion √©chou√©e: ${error.message}`);
    }
  }

  // √âcouter les changements d'authentification
  static onAuthStateChanged(callback) {
    return onAuthStateChanged(auth, callback);
  }

  // Obtenir l'utilisateur actuel
  static getCurrentUser() {
    return auth.currentUser;
  }

  // V√©rifier si l'utilisateur est authentifi√©
  static isAuthenticated() {
    return !!auth.currentUser;
  }

  // Recharger l'utilisateur
  static async reloadUser() {
    if (auth.currentUser) {
      await auth.currentUser.reload();
    }
  }

  // Mettre √† jour le nom d'utilisateur
  static async updateUserName(userId, userName) {
    if (!isOnline()) {
      console.warn('‚ö†Ô∏è Offline mode, cannot update user name');
      return;
    }

    try {
      return await retryWithBackoff(async () => {
        const userRef = doc(db, 'users', userId);
        await updateDoc(userRef, {
          name: userName,
          updatedAt: serverTimestamp(),
        });
        console.log('‚úÖ User name updated successfully');
      });
    } catch (error) {
      console.error('‚ùå Update user name failed:', error);
      throw new Error(`Impossible de mettre √† jour le nom: ${error.message}`);
    }
  }

  // Mettre √† jour le num√©ro de t√©l√©phone d'un utilisateur
  static async updateUserPhone(userId, phoneNumber) {
    console.log('üîÑ updateUserPhone appel√©e avec:', { userId, phoneNumber });

    if (!isOnline()) {
      throw new Error('Connexion requise pour mettre √† jour le t√©l√©phone');
    }

    try {
      await retryWithBackoff(async () => {
        console.log('üìù Mise √† jour du num√©ro dans Firestore...');

        // Normaliser le num√©ro de t√©l√©phone
        const normalizedPhone = phoneNumber?.replace(/\s/g, '');

        // V√©rifier le format
        const phoneRegex = /^(\+33|0)[1-9](\d{8})$/;
        if (!phoneRegex.test(normalizedPhone)) {
          throw new Error('Format de num√©ro invalide');
        }

        // Convertir 0X en +33X
        let finalPhone = normalizedPhone;
        if (finalPhone.startsWith('0')) {
          finalPhone = '+33' + finalPhone.substring(1);
        }

        // V√©rifier que le num√©ro n'est pas d√©j√† utilis√©
        const existingUserQuery = query(
          collection(db, 'users'),
          where('phone', '==', finalPhone),
          where('__name__', '!=', userId)
        );
        const existingUserSnapshot = await getDocs(existingUserQuery);

        if (!existingUserSnapshot.empty) {
          throw new Error(
            'Ce num√©ro de t√©l√©phone est d√©j√† utilis√© par un autre utilisateur'
          );
        }

        const userRef = doc(db, 'users', userId);
        await updateDoc(userRef, {
          phone: finalPhone,
          updatedAt: serverTimestamp(),
        });

        console.log(
          '‚úÖ Num√©ro de t√©l√©phone mis √† jour avec succ√®s:',
          finalPhone
        );
      });
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour t√©l√©phone:', error);
      throw new Error(
        `Impossible de mettre √† jour le t√©l√©phone: ${error.message}`
      );
    }
  }

  // Supprimer le num√©ro de t√©l√©phone d'un utilisateur
  static async removeUserPhone(userId) {
    console.log('üóëÔ∏è removeUserPhone appel√©e pour userId:', userId);

    if (!isOnline()) {
      throw new Error('Connexion requise pour supprimer le t√©l√©phone');
    }

    try {
      await retryWithBackoff(async () => {
        console.log('üìù Suppression du num√©ro dans Firestore...');

        const userRef = doc(db, 'users', userId);
        await updateDoc(userRef, {
          phone: '',
          updatedAt: serverTimestamp(),
        });

        console.log('‚úÖ Num√©ro de t√©l√©phone supprim√© avec succ√®s');
      });
    } catch (error) {
      console.error('‚ùå Erreur suppression t√©l√©phone:', error);
      throw new Error(`Impossible de supprimer le t√©l√©phone: ${error.message}`);
    }
  }

  // R√©-authentifier l'utilisateur si n√©cessaire pour la suppression
  static async reauthenticateForDeletion() {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      throw new Error('Aucun utilisateur connect√©');
    }

    // V√©rifier si l'utilisateur peut supprimer son compte
    try {
      // Test rapide pour v√©rifier les permissions
      await currentUser.getIdToken(true);
      return true;
    } catch (error) {
      if (error.code === 'auth/requires-recent-login') {
        return false;
      }
      throw error;
    }
  }

  // Supprimer compl√®tement un compte utilisateur
  static async deleteUserAccount(userId) {
    if (!isOnline()) {
      throw new Error('Connexion internet requise pour supprimer le compte');
    }

    try {
      console.log(`üóëÔ∏è Suppression compl√®te du compte ${userId}...`);

      // 0. V√©rifier d'abord si on peut supprimer le compte Auth
      const canDelete = await this.reauthenticateForDeletion();
      if (!canDelete) {
        throw new Error(
          'Pour des raisons de s√©curit√©, vous devez vous reconnecter avant de supprimer votre compte. ' +
            'Veuillez vous d√©connecter et vous reconnecter, puis r√©essayer.'
        );
      }

      await retryWithBackoff(async () => {
        // 1. Supprimer toutes les disponibilit√©s de l'utilisateur
        const availabilitiesQuery = query(
          collection(db, 'availabilities'),
          where('userId', '==', userId)
        );
        const availabilitiesSnapshot = await getDocs(availabilitiesQuery);
        for (const doc of availabilitiesSnapshot.docs) {
          await deleteDoc(doc.ref);
        }
        console.log('‚úÖ Disponibilit√©s supprim√©es');

        // 2. Supprimer toutes les notifications envoy√©es et re√ßues
        const notificationsToQuery = query(
          collection(db, 'notifications'),
          where('to', '==', userId)
        );
        const notificationsFromQuery = query(
          collection(db, 'notifications'),
          where('from', '==', userId)
        );

        const [notificationsToSnapshot, notificationsFromSnapshot] =
          await Promise.all([
            getDocs(notificationsToQuery),
            getDocs(notificationsFromQuery),
          ]);

        const notificationDeletePromises = [
          ...notificationsToSnapshot.docs.map(doc => deleteDoc(doc.ref)),
          ...notificationsFromSnapshot.docs.map(doc => deleteDoc(doc.ref)),
        ];
        await Promise.all(notificationDeletePromises);
        console.log('‚úÖ Notifications supprim√©es');

        // 3. Supprimer les relations d'amiti√©
        const friendsQuery = query(
          collection(db, 'friends'),
          where('users', 'array-contains', userId)
        );
        const friendsSnapshot = await getDocs(friendsQuery);
        for (const doc of friendsSnapshot.docs) {
          await deleteDoc(doc.ref);
        }
        console.log("‚úÖ Relations d'amiti√© supprim√©es");

        // 4. Supprimer le document utilisateur
        const userRef = doc(db, 'users', userId);
        await deleteDoc(userRef);
        console.log('‚úÖ Document utilisateur supprim√©');

        // 5. Supprimer l'utilisateur Firebase Auth
        const currentUser = auth.currentUser;
        if (currentUser && currentUser.uid === userId) {
          await currentUser.delete();
          console.log('‚úÖ Compte Firebase Auth supprim√©');
        }

        console.log('üéâ Suppression termin√©e avec succ√®s !');
      });

      return { success: true, verification: { success: true } };
    } catch (error) {
      console.error('‚ùå Erreur lors de la suppression du compte:', error);

      if (error.code === 'auth/requires-recent-login') {
        throw new Error(
          'Pour des raisons de s√©curit√©, vous devez vous reconnecter avant de supprimer votre compte. ' +
            'Veuillez vous d√©connecter et vous reconnecter, puis r√©essayer.'
        );
      }

      throw new Error(`Erreur lors de la suppression: ${error.message}`);
    }
  }

  // R√©cup√©rer le r√©sultat de la redirection Google
  static async getGoogleRedirectResult() {
    try {
      console.log('üîç Checking for Google redirect result...');

      const result = await getRedirectResult(auth);

      if (result) {
        console.log('‚úÖ Google redirect sign-in successful');

        const credential = GoogleAuthProvider.credentialFromResult(result);
        const token = credential?.accessToken;

        // Cr√©er le profil utilisateur
        if (result.user) {
          await this.createUserProfile(result.user);
        }

        return {
          user: result.user,
          credential,
          token,
        };
      }

      return null; // Pas de redirection en cours
    } catch (error) {
      console.error('‚ùå Google redirect result failed:', error);
      throw new Error(`R√©cup√©ration redirection √©chou√©e: ${error.message}`);
    }
  }

  // R√©cup√©rer le r√©sultat de la redirection Facebook
  static async getFacebookRedirectResult() {
    try {
      console.log('üîç Checking for Facebook redirect result...');

      const result = await getRedirectResult(auth);

      if (result) {
        console.log('‚úÖ Facebook redirect sign-in successful');

        const credential = FacebookAuthProvider.credentialFromResult(result);
        const token = credential?.accessToken;

        // Cr√©er le profil utilisateur
        if (result.user) {
          await this.createUserProfile(result.user);
        }

        return {
          user: result.user,
          credential,
          token,
        };
      }

      return null; // Pas de redirection en cours
    } catch (error) {
      console.error('‚ùå Facebook redirect result failed:', error);
      throw new Error(
        `R√©cup√©ration redirection Facebook √©chou√©e: ${error.message}`
      );
    }
  }

  // Nettoyer un compte Firebase Auth orphelin (sans donn√©es Firestore)
  static async cleanupOrphanedAuthAccount() {
    try {
      const currentUser = auth.currentUser;
      if (!currentUser) {
        console.log('‚ÑπÔ∏è Aucun utilisateur connect√© √† nettoyer');
        return false;
      }

      // V√©rifier si l'utilisateur a des donn√©es dans Firestore
      const userRef = doc(db, 'users', currentUser.uid);
      const userSnap = await getDoc(userRef);

      if (!userSnap.exists()) {
        console.log(
          'üîÑ Compte Auth sans donn√©es Firestore d√©tect√©, recr√©ation du profil...'
        );

        // Au lieu de supprimer le compte Auth, recr√©ons les donn√©es Firestore
        // Cela permet de r√©utiliser un compte apr√®s suppression des donn√©es
        try {
          await this.createUserProfile(currentUser);
          console.log(
            '‚úÖ Profil Firestore recr√©√© pour le compte Auth existant'
          );
          return false; // Pas de suppression, juste recr√©ation
        } catch (error) {
          console.error('‚ùå Erreur recr√©ation profil:', error);

          // En cas d'√©chec de recr√©ation, on peut toujours supprimer si n√©cessaire
          // Mais seulement pour de vrais comptes orphelins (plus de 1 jour)
          const creationTime = currentUser.metadata?.creationTime;
          const accountAge = creationTime
            ? Date.now() - new Date(creationTime).getTime()
            : 0;
          const oneDayMs = 24 * 60 * 60 * 1000;

          if (accountAge > oneDayMs && creationTime) {
            console.log('üßπ Compte Auth ancien sans donn√©es, suppression...');
            try {
              await currentUser.delete();
              console.log('‚úÖ Ancien compte Auth orphelin supprim√©');
              return true;
            } catch (deleteError) {
              if (deleteError.code === 'auth/requires-recent-login') {
                console.log(
                  '‚ö†Ô∏è Reconnexion requise pour supprimer le compte Auth orphelin'
                );
                throw new Error(
                  'Compte orphelin d√©tect√©. Veuillez vous reconnecter pour terminer la suppression.'
                );
              }
              throw deleteError;
            }
          } else {
            console.log(
              '‚ö†Ô∏è Compte Auth r√©cent sans donn√©es, conservation pour permettre recr√©ation'
            );
            return false;
          }
        }
      } else {
        console.log('‚ÑπÔ∏è Compte Auth normal avec donn√©es Firestore');
        return false;
      }
    } catch (error) {
      console.error('‚ùå Erreur nettoyage compte orphelin:', error);
      throw error;
    }
  }

  // Test de diagnostic pour identifier le probl√®me localhost
  static async diagnosePhoneAuth() {
    try {
      console.log('üîç DIAGNOSTIC: Test des configurations Firebase...');

      // V√©rifier la configuration
      console.log('üìã Firebase Config:', {
        apiKey: auth.app.options.apiKey.substring(0, 10) + '...',
        authDomain: auth.app.options.authDomain,
        projectId: auth.app.options.projectId,
      });

      // V√©rifier App Check
      console.log('üõ°Ô∏è App Check status:', {
        enabled: !!(/** @type {any} */ (window).firebase?.appCheck),
        debugToken: !!(
          /** @type {any} */ (window).FIREBASE_APPCHECK_DEBUG_TOKEN
        ),
      });

      // V√©rifier reCAPTCHA
      console.log('üîê reCAPTCHA config:', {
        siteKey:
          process.env.REACT_APP_RECAPTCHA_V3_SITE_KEY?.substring(0, 10) + '...',
        windowLocation: window.location.href,
      });

      // Test des param√®tres auth
      console.log('üîß Auth settings:', auth.settings);

      return {
        status: 'diagnostic_complete',
        url: window.location.href,
        userAgent: navigator.userAgent,
      };
    } catch (error) {
      console.error('‚ùå Diagnostic failed:', error);
      return { error: error.message };
    }
  }

  // Upload d'une photo de profil (solution alternative sans App Check)
  static async uploadUserPhoto(userId, file) {
    console.log('üì∑ uploadUserPhoto appel√©e avec:', {
      userId,
      fileSize: file.size,
      fileType: file.type,
    });

    if (!isOnline()) {
      throw new Error('Connexion requise pour uploader la photo');
    }

    // Solution alternative : convertir en base64 et stocker dans Firestore
    // Cela √©vite les probl√®mes App Check/CORS avec Firebase Storage
    try {
      console.log("üîÑ Compression et conversion de l'image...");

      // Compresser l'image si elle est trop grande
      const compressedFile = await this.compressImage(file, 800, 0.8);
      console.log('üìè Taille apr√®s compression:', compressedFile.size, 'bytes');

      const base64String = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const result = /** @type {string} */ (reader.result);
          // R√©cup√©rer seulement la partie base64 (sans le pr√©fixe data:image/...)
          const base64 = result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(compressedFile);
      });

      console.log('‚úÖ Image convertie en base64, taille:', base64String.length);

      const dataURL = `data:${compressedFile.type};base64,${base64String}`;

      // Stocker l'image base64 directement dans Firestore
      const photoData = {
        type: 'base64',
        data: base64String,
        mimeType: compressedFile.type,
        originalSize: file.size,
        compressedSize: compressedFile.size,
        uploadedAt: new Date().toISOString(),
      };

      await retryWithBackoff(async () => {
        // Mettre √† jour Firestore avec l'image base64
        const userRef = doc(db, 'users', userId);
        await updateDoc(userRef, {
          avatar: dataURL,
          avatarData: photoData,
          updatedAt: serverTimestamp(),
        });

        console.log('‚úÖ Photo de profil mise √† jour dans Firestore');
      });

      // Important : D√©clencher la synchronisation pour que les amis voient le changement
      console.log('üîÑ D√©clenchement de la synchronisation pour les amis...');
      await this.notifyFriendsOfProfileUpdate(userId);

      console.log('üîó Data URL cr√©√©e:', dataURL.substring(0, 100) + '...');
      console.log(
        'üìä Compression: ',
        file.size,
        '‚Üí',
        compressedFile.size,
        'bytes'
      );

      return dataURL;
    } catch (error) {
      console.error('‚ùå Erreur upload photo (base64):', error);
      throw new Error(`Impossible d'uploader la photo: ${error.message}`);
    }
  }

  // Notifier les amis d'une mise √† jour de profil pour forcer la synchronisation
  static async notifyFriendsOfProfileUpdate(userId) {
    try {
      // Cette m√©thode d√©clenche une mise √† jour dans la collection users
      // pour que les amis voient imm√©diatement les changements
      const userRef = doc(db, 'users', userId);
      await updateDoc(userRef, {
        profileUpdatedAt: serverTimestamp(),
        // Force la synchronisation temps r√©el avec les listeners des amis
        syncTrigger: new Date().getTime(),
      });
      console.log('‚úÖ Notification de mise √† jour de profil envoy√©e');
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur notification amis:', error);
      // Ce n'est pas critique, on continue
    }
  }

  // Compresser une image pour r√©duire sa taille
  static async compressImage(file, maxWidth = 800, quality = 0.8) {
    return new Promise(resolve => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();

      img.onload = () => {
        // Calculer les nouvelles dimensions en gardant le ratio
        let { width, height } = img;
        if (width > height) {
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }
        } else {
          if (height > maxWidth) {
            width = (width * maxWidth) / height;
            height = maxWidth;
          }
        }

        // Redimensionner le canvas
        canvas.width = width;
        canvas.height = height;

        // Dessiner l'image redimensionn√©e
        ctx.drawImage(img, 0, 0, width, height);

        // Convertir en blob avec compression
        canvas.toBlob(
          blob => {
            // Cr√©er un nouveau File avec le blob compress√©
            const compressedFile = new File([blob], file.name, {
              type: file.type,
              lastModified: Date.now(),
            });
            resolve(compressedFile);
          },
          file.type,
          quality
        );
      };

      // Charger l'image
      img.src = URL.createObjectURL(file);
    });
  }

  // ‚ö†Ô∏è NOUVEAU: Syst√®me de callbacks inspir√© d'Android OnVerificationStateChangedCallbacks
  static createPhoneAuthCallbacks(options = {}) {
    return {
      // √âquivalent Android: onVerificationCompleted
      onVerificationCompleted: phoneAuthCredential => {
        console.log('‚úÖ V√©rification automatique r√©ussie (comme Android)');
        if (options.onAutoVerified) {
          options.onAutoVerified(phoneAuthCredential);
        }
      },

      // √âquivalent Android: onVerificationFailed
      onVerificationFailed: error => {
        console.error('‚ùå √âchec de la v√©rification (comme Android):', error);
        const errorInfo = this.handleAuthError(error, 'phone verification');
        if (options.onVerificationError) {
          options.onVerificationError(errorInfo);
        }
      },

      // √âquivalent Android: onCodeSent
      onCodeSent: (verificationId, forceResendingToken) => {
        console.log('üì± Code SMS envoy√© (comme Android):', { verificationId });
        if (options.onCodeSent) {
          options.onCodeSent(verificationId, forceResendingToken);
        }
      },

      // ‚ö†Ô∏è SP√âCIFIQUE WEB: onReCaptchaResolved (n'existe pas sur Android)
      onReCaptchaResolved: recaptchaToken => {
        console.log('üîê reCAPTCHA r√©solu (sp√©cifique Web)');
        if (options.onReCaptchaResolved) {
          options.onReCaptchaResolved(recaptchaToken);
        }
      },

      // ‚ö†Ô∏è NOUVEAU: onAppCheckError (gestion sp√©cifique erreur 500)
      onAppCheckError: error => {
        console.error(
          'üö® Erreur App Check d√©tect√©e (cause erreur 500):',
          error
        );
        if (options.onAppCheckError) {
          options.onAppCheckError(error);
        }
      },
    };
  }

  // ‚ö†Ô∏è AM√âLIORATION: M√©thode centralis√©e de gestion des erreurs inspir√©e de la doc iOS
  static handleAuthError(error, context = 'authentication') {
    console.error(`‚ùå ${context} error:`, error);

    let userFriendlyMessage = "Erreur d'authentification";
    const technicalDetails = {
      code: error.code,
      message: error.message,
      context,
      timestamp: new Date().toISOString(),
    };

    // Gestion des erreurs sp√©cifiques selon les bonnes pratiques Firebase
    switch (error.code) {
      case 'auth/billing-not-enabled':
        userFriendlyMessage =
          'üí≥ Plan Firebase requis\n\n' +
          '‚úÖ Solutions :\n' +
          '1. Activez le plan Blaze dans Firebase Console\n' +
          '2. Ou utilisez les num√©ros de test : +33612345678 / 123456\n\n' +
          'üí° Les num√©ros de test fonctionnent gratuitement';
        break;

      case 'auth/invalid-phone-number':
        userFriendlyMessage =
          'üì± Num√©ro de t√©l√©phone invalide\n\n' +
          '‚úÖ Format requis : +33 6 12 34 56 78\n' +
          'üí° Exemple : +33677889876';
        break;

      case 'auth/too-many-requests':
        userFriendlyMessage =
          '‚è∞ Trop de tentatives\n\n' +
          '‚úÖ Attendez 15 minutes avant de r√©essayer\n' +
          'üí° Ou utilisez le bouton "üß™ Test SMS"';
        break;

      case 'auth/captcha-check-failed':
      case 'auth/app-check-token-invalid':
        userFriendlyMessage =
          'üîê V√©rification de s√©curit√© √©chou√©e\n\n' +
          '‚úÖ Solutions :\n' +
          '1. Rechargez la page\n' +
          '2. D√©sactivez App Check dans Firebase Console\n' +
          '3. Utilisez le bouton "üß™ Test SMS"';
        break;

      case 'auth/quota-exceeded':
        userFriendlyMessage =
          'üìä Quota SMS d√©pass√©\n\n' +
          '‚úÖ Revenez demain ou activez le plan Blaze\n' +
          'üí° Num√©ro de test : +33612345678 / 123456';
        break;

      case 'auth/network-request-failed':
        userFriendlyMessage =
          'üåê Probl√®me de connexion\n\n' +
          '‚úÖ V√©rifiez votre connexion internet\n' +
          'üí° R√©essayez dans quelques instants';
        break;

      case 'auth/internal-error':
        userFriendlyMessage =
          '‚öôÔ∏è Erreur interne Firebase\n\n' +
          '‚úÖ R√©essayez dans 5 minutes\n' +
          'üí° Si cela persiste, utilisez le test SMS';
        break;

      // ‚ö†Ô∏è NOUVEAU: Gestion sp√©cifique erreur 500 inspir√©e doc iOS
      case 'auth/app-not-authorized':
        userFriendlyMessage =
          'üö´ Application non autoris√©e\n\n' +
          '‚úÖ V√©rifiez dans Firebase Console :\n' +
          '1. Authentication > Settings > Authorized domains\n' +
          '2. Ajoutez votre domaine\n' +
          '3. D√©sactivez App Check temporairement';
        break;

      case 'auth/operation-not-allowed':
        userFriendlyMessage =
          'üîí Authentification par t√©l√©phone d√©sactiv√©e\n\n' +
          '‚úÖ Dans Firebase Console :\n' +
          '1. Authentication > Sign-in method\n' +
          '2. Activez "Phone" ‚úÖ\n' +
          '3. Configurez les num√©ros de test';
        break;

      default:
        // D√©tection des erreurs 500 bas√©e sur le message
        if (
          error.message &&
          (error.message.includes('500') ||
            error.message.includes('Internal Server Error') ||
            error.message.includes('sendVerificationCode'))
        ) {
          userFriendlyMessage =
            'üö® Erreur serveur Firebase (500)\n\n' +
            '‚ùå Cause : App Check activ√©\n\n' +
            '‚úÖ Solution IMM√âDIATE :\n' +
            '1. Firebase Console ‚Üí App Check ‚Üí D√âSACTIVER\n' +
            '2. Attendez 5-10 minutes\n' +
            '3. Utilisez le bouton "üß™ Test SMS" en attendant\n\n' +
            'üí° Num√©ro test : +33612345678 / Code : 123456';
        } else {
          userFriendlyMessage =
            error.message || "Erreur d'authentification inconnue";
        }
    }

    // Log technique pour le d√©bogage (inspir√© des bonnes pratiques iOS)
    console.group(`üîç D√©tails erreur ${context}`);
    console.table(technicalDetails);
    console.groupEnd();

    return {
      userMessage: userFriendlyMessage,
      technicalDetails,
      shouldRetry: [
        'auth/network-request-failed',
        'auth/internal-error',
      ].includes(error.code),
      canUseTestMode: true, // Toujours proposer le mode test
    };
  }
}
