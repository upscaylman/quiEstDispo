/**
 * Types et enums pour le systÃ¨me d'invitations Ã©vÃ©nements
 * Phase 1 - Refactoring du systÃ¨me d'Ã©tats
 * Phase 2 - SystÃ¨me de groupes
 */

// ===========================
// ENUMS D'Ã‰TATS UTILISATEUR
// ===========================

/**
 * Ã‰tats possibles d'un utilisateur dans le systÃ¨me d'Ã©vÃ©nements
 * RÃ¨gle mÃ©tier: Un utilisateur ne peut Ãªtre que dans UN seul Ã©tat Ã  la fois
 */
export const UserEventStatus = {
  LIBRE: 'libre', // Peut envoyer/recevoir des invitations
  INVITATION_ENVOYEE: 'invitation_envoyee', // A envoyÃ© une invitation, en attente de rÃ©ponse
  INVITATION_RECUE: 'invitation_recue', // A reÃ§u une invitation, doit rÃ©pondre
  EN_PARTAGE: 'en_partage', // Partage actif de localisation/disponibilitÃ©
};

/**
 * Statuts des invitations
 */
export const InvitationStatus = {
  PENDING: 'pending',
  ACCEPTED: 'accepted',
  DECLINED: 'declined',
  EXPIRED: 'expired',
};

/**
 * Types de relations entre utilisateurs dans le contexte d'Ã©vÃ©nements
 */
export const RelationshipType = {
  NONE: 'none', // Aucune relation active
  INVITATION_SENT: 'invitation_sent', // A envoyÃ© une invitation
  INVITATION_RECEIVED: 'invitation_received', // A reÃ§u une invitation
  IN_SAME_GROUP: 'in_same_group', // Dans le mÃªme groupe actif
};

// ===========================
// PHASE 2 - SYSTÃˆME DE GROUPES
// ===========================

/**
 * ModÃ¨le d'un groupe d'Ã©vÃ©nement
 * RÃ¨gle mÃ©tier: Limite max de 10 personnes par groupe
 */
export const EventGroupModel = {
  id: '', // ID unique du groupe
  eventId: '', // ID de l'Ã©vÃ©nement associÃ©
  createdBy: '', // UserID du crÃ©ateur
  members: [], // Array de UserIDs des membres
  createdAt: null, // Date de crÃ©ation
  maxMembers: 10, // Limite maximale (constante)
  activity: '', // Type d'activitÃ© (coffee, lunch, etc.)
  isActive: true, // Statut du groupe
  lastActivity: null, // DerniÃ¨re activitÃ© du groupe
};

/**
 * Statuts d'un membre dans un groupe
 */
export const GroupMemberStatus = {
  ACTIVE: 'active', // Membre actif et en ligne
  OFFLINE: 'offline', // Membre du groupe mais hors ligne
  LEFT: 'left', // A quittÃ© le groupe
};

/**
 * Types d'Ã©vÃ©nements de groupe (pour l'historique)
 */
export const GroupEventType = {
  CREATED: 'created', // Groupe crÃ©Ã©
  MEMBER_JOINED: 'member_joined', // Nouveau membre rejoint
  MEMBER_LEFT: 'member_left', // Membre a quittÃ©
  ACTIVITY_CHANGED: 'activity_changed', // ActivitÃ© modifiÃ©e
  GROUP_ENDED: 'group_ended', // Groupe terminÃ©
};

// ===========================
// MODÃˆLES Ã‰TENDUS PHASE 2
// ===========================

/**
 * ModÃ¨le utilisateur Ã©tendu pour Phase 2
 */
export const ExtendedUserModel = {
  // Phase 1 - Ã‰tats
  eventStatus: UserEventStatus.LIBRE,
  currentEventId: null,
  currentGroupId: null, // ðŸŽ¯ NOUVEAU: ID du groupe actuel
  pendingInvitations: [],

  // Phase 2 - Groupes
  groupHistory: [], // ðŸŽ¯ NOUVEAU: Historique des groupes rejoints
  groupRole: null, // ðŸŽ¯ NOUVEAU: 'creator' | 'member' | null
  lastGroupActivity: null, // ðŸŽ¯ NOUVEAU: DerniÃ¨re activitÃ© de groupe
  groupNotifications: true, // ðŸŽ¯ NOUVEAU: Notifications de groupe activÃ©es
};

/**
 * ModÃ¨le d'invitation Ã©tendu pour Phase 2 + 3
 */
export const ExtendedInvitationModel = {
  id: '',
  eventId: '',
  fromUserId: '',
  toUserIds: [], // Support multi-destinataires (Phase 3)
  groupId: null, // ðŸŽ¯ NOUVEAU: Si c'est pour rejoindre un groupe existant
  status: InvitationStatus.PENDING,
  createdAt: null,
  expiresAt: null, // ðŸš¨ CRITIQUE Phase 3: Auto-expiration aprÃ¨s 10min

  // Phase 2 - Groupes
  isGroupInvitation: false, // ðŸŽ¯ NOUVEAU: Invitation pour rejoindre un groupe
  groupSize: 1, // ðŸŽ¯ NOUVEAU: Taille actuelle du groupe
  invitationType: 'individual', // ðŸŽ¯ NOUVEAU: 'individual' | 'group'

  // Phase 3 - Invitations multiples intelligentes
  isMultipleInvitation: false, // ðŸš¨ NOUVEAU: Invitation Ã  plusieurs destinataires
  totalRecipients: 1, // ðŸš¨ NOUVEAU: Nombre total de destinataires
  acceptedByUserIds: [], // ðŸš¨ NOUVEAU: IDs utilisateurs ayant acceptÃ©
  declinedByUserIds: [], // ðŸš¨ NOUVEAU: IDs utilisateurs ayant dÃ©clinÃ©
  activity: '', // ðŸš¨ NOUVEAU: ActivitÃ© demandÃ©e (coffee, lunch...)
  priority: 'normal', // ðŸš¨ NOUVEAU: 'high' | 'normal' | 'low' pour conflits
  conflictsWith: [], // ðŸš¨ NOUVEAU: IDs autres invitations en conflit
  autoExpired: false, // ðŸš¨ NOUVEAU: ExpirÃ©e automatiquement
  expirationNotificationSent: false, // ðŸš¨ NOUVEAU: Notification d'expiration envoyÃ©e
};

// ===========================
// CONSTANTES
// ===========================

export const EVENT_CONSTANTS = {
  MAX_GROUP_SIZE: 10, // Taille maximale d'un groupe
  MIN_GROUP_SIZE: 2, // Taille minimale pour former un groupe
  INVITATION_EXPIRY_MINUTES: 10, // Expiration des invitations en minutes
  GROUP_CLEANUP_HOURS: 24, // Nettoyage des groupes inactifs

  // Phase 3 - Invitations multiples
  MAX_MULTIPLE_RECIPIENTS: 8, // ðŸš¨ NOUVEAU: Maximum destinataires par invitation multiple
  INVITATION_COOLDOWN_SECONDS: 30, // ðŸš¨ NOUVEAU: Cooldown anti-spam entre invitations
  CONFLICT_PRIORITY_TIMEOUT_MINUTES: 5, // ðŸš¨ NOUVEAU: Timeout prioritÃ© en cas de conflit
  EXPIRATION_CHECK_INTERVAL_MINUTES: 1, // ðŸš¨ NOUVEAU: Intervalle vÃ©rification expiration

  // Collections Firestore
  COLLECTIONS: {
    USERS: 'users',
    EVENTS: 'events',
    GROUPS: 'groups',
    INVITATIONS: 'invitations',
    NOTIFICATIONS: 'notifications',
  },
};

// ===========================
// FONCTIONS UTILITAIRES PHASE 1
// ===========================

/**
 * Valide si une transition d'Ã©tat est autorisÃ©e
 */
export const isValidStatusTransition = (fromStatus, toStatus) => {
  if (!fromStatus || !toStatus) return false;

  const validTransitions = {
    [UserEventStatus.LIBRE]: [
      UserEventStatus.INVITATION_ENVOYEE,
      UserEventStatus.INVITATION_RECUE,
      UserEventStatus.EN_PARTAGE,
    ],
    [UserEventStatus.INVITATION_ENVOYEE]: [
      UserEventStatus.LIBRE,
      UserEventStatus.EN_PARTAGE,
    ],
    [UserEventStatus.INVITATION_RECUE]: [
      UserEventStatus.LIBRE,
      UserEventStatus.EN_PARTAGE,
    ],
    [UserEventStatus.EN_PARTAGE]: [UserEventStatus.LIBRE],
  };

  return validTransitions[fromStatus]?.includes(toStatus) || false;
};

/**
 * DÃ©termine si un utilisateur peut envoyer des invitations selon son Ã©tat
 */
export const canSendInvitations = status => {
  return status === UserEventStatus.LIBRE;
};

/**
 * DÃ©termine si un utilisateur peut recevoir des invitations selon son Ã©tat
 */
export const canReceiveInvitations = status => {
  return status === UserEventStatus.LIBRE;
};

/**
 * Obtient le message d'affichage pour un Ã©tat
 */
export const getStatusMessage = (status, activity = null) => {
  switch (status) {
    case UserEventStatus.LIBRE:
      return 'Libre';
    case UserEventStatus.INVITATION_ENVOYEE:
      return 'Invitation envoyÃ©e';
    case UserEventStatus.INVITATION_RECUE:
      return 'Invitation reÃ§ue';
    case UserEventStatus.EN_PARTAGE:
      return activity ? `En partage - ${activity}` : 'En partage';
    default:
      return 'Ã‰tat inconnu';
  }
};

/**
 * Obtient la couleur d'affichage pour un Ã©tat
 */
export const getStatusColor = status => {
  switch (status) {
    case UserEventStatus.LIBRE:
      return 'green';
    case UserEventStatus.INVITATION_ENVOYEE:
      return 'orange';
    case UserEventStatus.INVITATION_RECUE:
      return 'blue';
    case UserEventStatus.EN_PARTAGE:
      return 'purple';
    default:
      return 'gray';
  }
};

// ===========================
// FONCTIONS UTILITAIRES PHASE 2 - GROUPES
// ===========================

/**
 * Valide si un groupe peut accepter un nouveau membre
 */
export const canGroupAcceptMember = (
  currentSize,
  maxSize = EVENT_CONSTANTS.MAX_GROUP_SIZE
) => {
  return currentSize < maxSize;
};

/**
 * DÃ©termine si une taille constitue un "groupe" (vs 1v1)
 */
export const isGroupSize = memberCount => {
  return memberCount >= EVENT_CONSTANTS.MIN_GROUP_SIZE;
};

/**
 * Calcule la progression de formation du groupe (1v1 â†’ groupe complet)
 */
export const getGroupProgress = (
  currentSize,
  maxSize = EVENT_CONSTANTS.MAX_GROUP_SIZE
) => {
  if (currentSize <= 0) return 0;
  return Math.min((currentSize / maxSize) * 100, 100);
};

/**
 * Obtient le message d'affichage pour la taille du groupe
 */
export const getGroupSizeMessage = memberCount => {
  if (memberCount === 1) return 'Seul(e)';
  if (memberCount === 2) return 'En duo';
  if (memberCount <= 5) return `Groupe de ${memberCount}`;
  if (memberCount <= 8) return `Grand groupe (${memberCount})`;
  return `Groupe complet (${memberCount}/${EVENT_CONSTANTS.MAX_GROUP_SIZE})`;
};

/**
 * DÃ©termine la couleur d'affichage selon la taille du groupe
 */
export const getGroupSizeColor = (
  memberCount,
  maxSize = EVENT_CONSTANTS.MAX_GROUP_SIZE
) => {
  const ratio = memberCount / maxSize;
  if (ratio < 0.3) return 'blue'; // Petit groupe
  if (ratio < 0.7) return 'green'; // Groupe moyen
  if (ratio < 1.0) return 'orange'; // Groupe presque plein
  return 'red'; // Groupe complet
};

/**
 * Valide la structure d'un groupe
 */
export const validateGroupStructure = group => {
  if (!group || typeof group !== 'object')
    return { valid: false, error: 'Groupe invalide' };

  if (!group.id || typeof group.id !== 'string') {
    return { valid: false, error: 'ID de groupe manquant' };
  }

  if (!group.eventId || typeof group.eventId !== 'string') {
    return { valid: false, error: "ID d'Ã©vÃ©nement manquant" };
  }

  if (!group.createdBy || typeof group.createdBy !== 'string') {
    return { valid: false, error: 'CrÃ©ateur manquant' };
  }

  if (!Array.isArray(group.members)) {
    return { valid: false, error: 'Liste de membres invalide' };
  }

  if (group.members.length > EVENT_CONSTANTS.MAX_GROUP_SIZE) {
    return { valid: false, error: 'Trop de membres dans le groupe' };
  }

  if (!group.members.includes(group.createdBy)) {
    return { valid: false, error: 'Le crÃ©ateur doit Ãªtre membre du groupe' };
  }

  return { valid: true };
};

/**
 * CrÃ©e un modÃ¨le de groupe par dÃ©faut
 */
export const createDefaultGroup = (eventId, creatorId, activity) => {
  return {
    ...EventGroupModel,
    id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    eventId,
    createdBy: creatorId,
    members: [creatorId],
    createdAt: new Date(),
    activity,
    lastActivity: new Date(),
  };
};

// ===========================
// FONCTIONS UTILITAIRES PHASE 3 - INVITATIONS MULTIPLES
// ===========================

/**
 * Statuts d'invitation Ã©tendus pour Phase 3
 */
export const InvitationPriority = {
  HIGH: 'high', // PrioritÃ© haute (pour conflits)
  NORMAL: 'normal', // PrioritÃ© normale
  LOW: 'low', // PrioritÃ© basse
};

/**
 * Types de conflit d'invitation
 */
export const ConflictType = {
  SIMULTANEOUS: 'simultaneous', // Invitations reÃ§ues simultanÃ©ment
  OVERLAPPING: 'overlapping', // Invitations qui se chevauchent
  DUPLICATE: 'duplicate', // MÃªme expÃ©diteur, mÃªme activitÃ©
};

/**
 * VÃ©rifie si une invitation est expirÃ©e
 */
export const isInvitationExpired = invitation => {
  if (!invitation.expiresAt) return false;

  const expirationTime = invitation.expiresAt.toDate
    ? invitation.expiresAt.toDate().getTime()
    : new Date(invitation.expiresAt).getTime();

  return Date.now() > expirationTime;
};

/**
 * Calcule la date d'expiration pour une nouvelle invitation
 */
export const calculateExpirationDate = (
  minutesFromNow = EVENT_CONSTANTS.INVITATION_EXPIRY_MINUTES
) => {
  return new Date(Date.now() + minutesFromNow * 60 * 1000);
};

/**
 * Valide si un utilisateur peut envoyer une invitation multiple
 */
export const canSendMultipleInvitation = (userStatus, recipientCount) => {
  if (userStatus !== UserEventStatus.LIBRE)
    return {
      canSend: false,
      reason: 'Utilisateur non libre',
    };

  if (recipientCount > EVENT_CONSTANTS.MAX_MULTIPLE_RECIPIENTS)
    return {
      canSend: false,
      reason: `Maximum ${EVENT_CONSTANTS.MAX_MULTIPLE_RECIPIENTS} destinataires`,
    };

  if (recipientCount < 1)
    return {
      canSend: false,
      reason: 'Au moins un destinataire requis',
    };

  return { canSend: true };
};

/**
 * DÃ©termine la prioritÃ© d'une invitation basÃ©e sur le contexte
 */
export const getInvitationPriority = invitationContext => {
  // Si c'est une rÃ©ponse Ã  une invitation existante
  if (invitationContext.isResponse) return InvitationPriority.HIGH;

  // Si l'expÃ©diteur est dÃ©jÃ  en relation active
  if (invitationContext.hasActiveRelation) return InvitationPriority.HIGH;

  // Si c'est une invitation de groupe
  if (invitationContext.isGroupInvitation) return InvitationPriority.NORMAL;

  // Par dÃ©faut
  return InvitationPriority.NORMAL;
};

/**
 * Formate le message d'invitation multiple pour l'affichage
 */
export const formatMultipleInvitationMessage = invitation => {
  const { fromUserName, activity, totalRecipients, acceptedByUserIds } =
    invitation;
  const acceptedCount = acceptedByUserIds.length;

  if (totalRecipients === 1) {
    return `ðŸŽ‰ ${fromUserName} vous invite pour ${activity}`;
  }

  if (acceptedCount === 0) {
    return `ðŸŽ‰ ${fromUserName} vous invite pour ${activity} (${totalRecipients} invitÃ©s)`;
  }

  return `ðŸŽ‰ ${fromUserName} vous invite pour ${activity} (${acceptedCount}/${totalRecipients} ont acceptÃ©)`;
};

/**
 * VÃ©rifie les conflits entre invitations
 */
export const detectInvitationConflicts = (
  newInvitation,
  existingInvitations
) => {
  const conflicts = [];

  existingInvitations.forEach(existing => {
    // Conflit si mÃªme expÃ©diteur + mÃªme activitÃ© + encore active
    if (
      existing.fromUserId === newInvitation.fromUserId &&
      existing.activity === newInvitation.activity &&
      existing.status === InvitationStatus.PENDING &&
      !isInvitationExpired(existing)
    ) {
      conflicts.push({
        type: ConflictType.DUPLICATE,
        conflictingInvitation: existing,
        reason: 'Invitation similaire dÃ©jÃ  en cours',
      });
    }

    // Conflit si invitations overlapping dans le temps
    if (
      existing.status === InvitationStatus.PENDING &&
      !isInvitationExpired(existing) &&
      existing.fromUserId !== newInvitation.fromUserId
    ) {
      conflicts.push({
        type: ConflictType.SIMULTANEOUS,
        conflictingInvitation: existing,
        reason: 'Invitations simultanÃ©es dÃ©tectÃ©es',
      });
    }
  });

  return conflicts;
};
